# Tests disabled by Infra Orchestrator (skip_tests enabled)
# Docker Application CI/CD Pipeline
# Auto-generated for containerized application

stages:
  - build
  - deploy


# Build Docker image using Azure Container Registry Tasks
# This builds in Azure infrastructure (unlimited disk space!) instead of GitLab runner
# ACR Task is created/updated by orchestrator when "Refresh Configs" is clicked
# Token is passed via --git-access-token to ensure fresh access to GitLab repository
build_to_acr:
  stage: build
  image: mcr.microsoft.com/azure-cli:latest
  variables:
    ACR_TASK_NAME: "irmai-kg-v2-surrealdb"
    ACR_NAME: "irmaiuatregistry"
    ACR_REGISTRY: "irmaiuatregistry.azurecr.io"
    ACR_RESOURCE_GROUP: "rg-irmai-uat-us-1"
    APP_NAME: "irmai-kg-v2-surrealdb"
    ORCHESTRATOR_URL: "https://b5cefeed5009.ngrok-free.app"
    GIT_REF: "$CI_COMMIT_REF_NAME"
  before_script:
    - echo "=== Using Azure Container Registry Tasks ==="
    - 'echo "ACR: $ACR_REGISTRY"'
    - 'echo "Task: $ACR_TASK_NAME"'
    - 'echo "Image: $ACR_REGISTRY/$APP_NAME:$CI_COMMIT_SHORT_SHA"'
    - echo "Building in Azure (no GitLab runner disk space limitations!)"
    - |
      # Azure login - skip managed identity (not available on GitLab runners)
      if [ -z "$AZURE_CLIENT_ID" ] || [ -z "$AZURE_CLIENT_SECRET" ] || [ -z "$AZURE_TENANT_ID" ]; then
        echo "‚ö†Ô∏è  Azure credentials not set - ACR Task may fail"
        echo "   Set AZURE_CLIENT_ID, AZURE_CLIENT_SECRET, AZURE_TENANT_ID as CI/CD variables"
      else
        echo "üîê Logging in to Azure with service principal..."
        az login --service-principal -u "$AZURE_CLIENT_ID" -p "$AZURE_CLIENT_SECRET" --tenant "$AZURE_TENANT_ID" --output none
        echo "‚úÖ Azure login successful"
      fi
  script:
    - |
      # Enable error handling
      set -e
      set -o pipefail
      
      echo "=========================================="
      echo "üöÄ ACR Task Build - Starting"
      echo "=========================================="
      echo ""
      echo "üìã Configuration:"
      echo "   Task Name: $ACR_TASK_NAME"
      echo "   Registry: $ACR_NAME"
      echo "   Resource Group: $ACR_RESOURCE_GROUP"
      echo "   Git Ref: $GIT_REF"
      echo "   Commit SHA: $CI_COMMIT_SHORT_SHA"
      echo "   Image: $ACR_REGISTRY/$APP_NAME:$CI_COMMIT_SHORT_SHA"
      echo ""
      
      # Step 1: Verify ACR Task exists
      echo "=========================================="
      echo "STEP 1: Verifying ACR Task exists"
      echo "=========================================="
      echo "Command: az acr task show --name $ACR_TASK_NAME --registry $ACR_NAME --resource-group $ACR_RESOURCE_GROUP"
      echo ""
      
      set +e  # Don't exit on error yet
      TASK_CHECK_OUTPUT=$(az acr task show --name $ACR_TASK_NAME --registry $ACR_NAME --resource-group $ACR_RESOURCE_GROUP 2>&1)
      TASK_CHECK_EXIT=$?
      set -e
      
      echo "Exit code: $TASK_CHECK_EXIT"
      echo "Output:"
      echo "$TASK_CHECK_OUTPUT"
      echo ""
      
      if [ $TASK_CHECK_EXIT -ne 0 ]; then
        echo "‚ùå ERROR: ACR Task does not exist or is not accessible!"
        echo ""
        echo "üí° SOLUTION: Click 'Refresh Configs' in orchestrator UI to create the ACR Task"
        echo "   URL: http://localhost:3331/gitlab/applications/{projectId}"
        echo ""
        exit 1
      fi
      
      echo "‚úÖ ACR Task exists and is accessible"
      echo ""
      
      # Step 2: Trigger ACR Task
      echo "=========================================="
      echo "STEP 2: Triggering ACR Task"
      echo "=========================================="
      echo "Command: az acr task run --name $ACR_TASK_NAME --registry $ACR_NAME --resource-group $ACR_RESOURCE_GROUP --set GIT_REF=$GIT_REF --query 'runId' -o tsv"
      echo ""
      echo "Note: ACR Task uses token stored during creation (from GitLab integration)"
      echo "      If this fails with 'failed to download context', click 'Refresh Configs' to update token"
      echo ""
      
      set +e  # Don't exit on error - we want to capture output
      RUN_ID_OUTPUT=$(az acr task run \
        --name $ACR_TASK_NAME \
        --registry $ACR_NAME \
        --resource-group $ACR_RESOURCE_GROUP \
        --set GIT_REF=$GIT_REF \
        --query 'runId' -o tsv 2>&1)
      RUN_ID_EXIT=$?
      set -e
      
      echo "Exit code: $RUN_ID_EXIT"
      echo "Full output:"
      echo "----------------------------------------"
      echo "$RUN_ID_OUTPUT"
      echo "----------------------------------------"
      echo ""
      
      if [ $RUN_ID_EXIT -ne 0 ]; then
        echo "‚ùå ERROR: Failed to trigger ACR Task"
        echo ""
        echo "üîç Troubleshooting:"
        echo "   1. Check if task exists:"
        echo "      az acr task show --name $ACR_TASK_NAME --registry $ACR_NAME --resource-group $ACR_RESOURCE_GROUP"
        echo ""
        echo "   2. Check service principal permissions:"
        echo "      az role assignment list --assignee $AZURE_CLIENT_ID"
        echo ""
        echo "   3. If error is 'failed to download context':"
        echo "      - Token stored in ACR Task may be expired"
        echo "      - Click 'Refresh Configs' to recreate task with fresh token"
        echo ""
        echo "   4. Check ACR Task configuration:"
        echo "      az acr task show --name $ACR_TASK_NAME --registry $ACR_NAME --resource-group $ACR_RESOURCE_GROUP -o json"
        echo ""
        exit 1
      fi
      
      # Extract RUN_ID from output
      echo "=========================================="
      echo "STEP 3: Extracting Run ID"
      echo "=========================================="
      echo "Parsing output to extract Run ID..."
      echo ""
      
      # Method 1: Look for "run with ID: xxx" pattern
      RUN_ID=$(echo "$RUN_ID_OUTPUT" | grep -oE 'run with ID: [a-z0-9]{3,4}' | sed 's/.*: //' | head -1 || echo "")
      
      # Method 2: Look for standalone 3-4 character alphanumeric strings
      if [ -z "$RUN_ID" ]; then
        RUN_ID=$(echo "$RUN_ID_OUTPUT" | grep -oE '\b[a-z0-9]{3,4}\b' | head -1 || echo "")
      fi
      
      # Method 3: Look for exact match on a line
      if [ -z "$RUN_ID" ]; then
        RUN_ID=$(echo "$RUN_ID_OUTPUT" | grep -xE '[a-z0-9]{3,4}' | head -1 | tr -d '[:space:]' || echo "")
      fi
      
      # Method 4: Try JSON parsing
      if [ -z "$RUN_ID" ]; then
        RUN_ID=$(echo "$RUN_ID_OUTPUT" | grep -oE '"runId"[[:space:]]*:[[:space:]]*"[a-z0-9]{3,4}"' | sed 's/.*"runId"[[:space:]]*:[[:space:]]*"//' | sed 's/".*//' | head -1 || echo "")
      fi
      
      if [ -z "$RUN_ID" ]; then
        echo "‚ùå ERROR: Failed to extract Run ID from output"
        echo ""
        echo "Raw output:"
        echo "----------------------------------------"
        echo "$RUN_ID_OUTPUT"
        echo "----------------------------------------"
        echo ""
        echo "Expected format: 3-4 character alphanumeric string (e.g., 'cak', 'car', 'ca12')"
        exit 1
      fi
      
      RUN_ID=$(echo "$RUN_ID" | tr -d '[:space:]')
      echo "‚úÖ Extracted Run ID: $RUN_ID"
      echo ""
      
      # Step 4: Wait for build to complete
      echo "=========================================="
      echo "STEP 4: Waiting for build to complete"
      echo "=========================================="
      echo "Run ID: $RUN_ID"
      echo "Timeout: 1800 seconds (30 minutes)"
      echo "Check interval: 10 seconds"
      echo ""
      
      TIMEOUT=1800
      ELAPSED=0
      INTERVAL=10
      BUILD_COMPLETED=false
      LAST_STATUS=""
      
      while [ $ELAPSED -lt $TIMEOUT ] && [ "$BUILD_COMPLETED" != "true" ]; do
        set +e
        STATUS_OUTPUT=$(az acr task show-run \
          --registry $ACR_NAME \
          --run-id $RUN_ID \
          --resource-group $ACR_RESOURCE_GROUP \
          --query 'status' -o tsv 2>&1)
        STATUS_EXIT_CODE=$?
        set -e
        
        STATUS=$(echo "$STATUS_OUTPUT" | head -n 1 | tr -d '[:space:]')
        
        # Log status changes or every 60 seconds
        if [ "$STATUS" != "$LAST_STATUS" ] || [ $((ELAPSED % 60)) -eq 0 ]; then
          if [ -n "$STATUS" ] && [ "$STATUS" != "" ]; then
            echo "üìä Status: $STATUS (elapsed: ${ELAPSED}s)"
          else
            echo "‚ö†Ô∏è  Status check failed (exit code: $STATUS_EXIT_CODE)"
            echo "   Output: $STATUS_OUTPUT"
          fi
          LAST_STATUS="$STATUS"
        fi
        
        if [ $STATUS_EXIT_CODE -eq 0 ] && [ -n "$STATUS" ]; then
          case "$STATUS" in
            Succeeded|succeeded|SUCCEEDED)
              echo ""
              echo "‚úÖ Build completed successfully!"
              BUILD_COMPLETED=true
              break
              ;;
            Failed|failed|FAILED)
              echo ""
              echo "‚ùå ERROR: Build failed (status: $STATUS)"
              echo ""
              echo "Getting build logs..."
              set +e
              az acr task logs --registry $ACR_NAME --run-id $RUN_ID --resource-group $ACR_RESOURCE_GROUP 2>&1 | head -50
              set -e
              exit 1
              ;;
          esac
        fi
        
        sleep $INTERVAL
        ELAPSED=$((ELAPSED + INTERVAL))
      done
      
      if [ "$BUILD_COMPLETED" != "true" ]; then
        echo ""
        echo "‚è∞ WARNING: Timeout reached after $TIMEOUT seconds"
        echo "Performing final status check..."
        echo ""
        
        set +e
        FINAL_STATUS_OUTPUT=$(az acr task show-run \
          --registry $ACR_NAME \
          --run-id $RUN_ID \
          --resource-group $ACR_RESOURCE_GROUP \
          --query 'status' -o tsv 2>&1)
        FINAL_EXIT=$?
        set -e
        
        FINAL_STATUS=$(echo "$FINAL_STATUS_OUTPUT" | head -n 1 | tr -d '[:space:]')
        
        echo "Final status check result (exit code: $FINAL_EXIT):"
        echo "$FINAL_STATUS_OUTPUT"
        echo ""
        
        case "$FINAL_STATUS" in
          Succeeded|succeeded|SUCCEEDED)
            echo "‚úÖ Build completed successfully (status check was delayed)"
            BUILD_COMPLETED=true
            ;;
          *)
            echo "‚ùå ERROR: Build did not complete in time"
            echo "   Final status: $FINAL_STATUS"
            echo ""
            echo "Getting build logs..."
            set +e
            az acr task logs --registry $ACR_NAME --run-id $RUN_ID --resource-group $ACR_RESOURCE_GROUP 2>&1 | head -50
            set -e
            exit 1
            ;;
        esac
      fi
      
      # Step 5: Get built image and retag
      echo ""
      echo "=========================================="
      echo "STEP 5: Getting built image and retagging"
      echo "=========================================="
      
      set +e
      ACTUAL_IMAGE_OUTPUT=$(az acr task show-run \
        --registry $ACR_NAME \
        --run-id $RUN_ID \
        --resource-group $ACR_RESOURCE_GROUP \
        --query 'outputImages[0]' -o tsv 2>&1)
      IMAGE_EXIT=$?
      set -e
      
      echo "Command exit code: $IMAGE_EXIT"
      echo "Output: $ACTUAL_IMAGE_OUTPUT"
      echo ""
      
      if [ $IMAGE_EXIT -eq 0 ] && [ -n "$ACTUAL_IMAGE_OUTPUT" ] && [[ ! "$ACTUAL_IMAGE_OUTPUT" == *"error"* ]]; then
        ACTUAL_IMAGE="$ACTUAL_IMAGE_OUTPUT"
        echo "‚úÖ Got built image from task run: $ACTUAL_IMAGE"
      else
        echo "‚ö†Ô∏è  Could not get built image from task run, using expected format"
        ACTUAL_IMAGE="$ACR_REGISTRY/$APP_NAME:$RUN_ID"
        echo "   Using: $ACTUAL_IMAGE"
      fi
      echo ""
      
      echo "üè∑Ô∏è  Retagging with commit SHA: $CI_COMMIT_SHORT_SHA"
      IMAGE_NAME_ONLY=$(echo "$ACTUAL_IMAGE" | sed 's/.*\///' | sed 's/:.*//')
      SOURCE_TAG=$(echo "$ACTUAL_IMAGE" | sed 's/.*://')
      
      echo "   Source: $ACR_REGISTRY/$IMAGE_NAME_ONLY:$SOURCE_TAG"
      echo "   Target: $IMAGE_NAME_ONLY:$CI_COMMIT_SHORT_SHA"
      echo ""
      
      set +e
      RETAG_OUTPUT=$(az acr import \
        --name $ACR_NAME \
        --source "$ACR_REGISTRY/$IMAGE_NAME_ONLY:$SOURCE_TAG" \
        --image "$IMAGE_NAME_ONLY:$CI_COMMIT_SHORT_SHA" \
        --resource-group $ACR_RESOURCE_GROUP 2>&1)
      RETAG_EXIT=$?
      set -e
      
      echo "Retag command exit code: $RETAG_EXIT"
      if [ $RETAG_EXIT -ne 0 ]; then
        echo "‚ö†Ô∏è  Retagging failed (this is often expected for same-registry imports)"
        echo "   Output: $RETAG_OUTPUT"
        echo "   Note: Image exists with Run.ID tag ($RUN_ID), deployment can use that"
      else
        echo "‚úÖ Successfully retagged: $ACR_REGISTRY/$IMAGE_NAME_ONLY:$CI_COMMIT_SHORT_SHA"
      fi
      echo ""
      
      echo "=========================================="
      echo "‚úÖ‚úÖ‚úÖ ACR Task Build Complete!"
      echo "=========================================="
      echo "   Run ID: $RUN_ID"
      echo "   Built image: $ACTUAL_IMAGE"
      echo "   Commit SHA tag: $ACR_REGISTRY/$APP_NAME:$CI_COMMIT_SHORT_SHA"
      echo "=========================================="
        - "[ -z \"$ORCHESTRATOR_URL\" ] && echo \"ORCHESTRATOR_URL not set; skipping Key Vault secret download\" && exit 0"
    - apk add --no-cache curl >/tmp/curl-install.log 2>&1 || { echo "‚ö†Ô∏è  Failed to install curl"; cat /tmp/curl-install.log; exit 1; }
    - "response_status=$(curl -sS -o keyvault.env -w \"%{http_code}\" -X POST \"$ORCHESTRATOR_URL/keyvault/env\" -H \"Content-Type: application/json\" -d '{\"application_name\":\"'$CI_PROJECT_NAME'\",\"format\":\"dotenv\"}}')"
    - "[ \"$response_status\" = \"200\" ] && mv keyvault.env .env && echo \"‚úÖ Secrets written to .env\" || (rm -f keyvault.env && echo \"‚ÑπÔ∏è  No secrets fetched from orchestrator (status $response_status)\")"
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - if: $TRIGGER_DEPLOY == "true"
      when: on_success
    - exists:
        - Dockerfile
      when: on_success


# Deployment job added by Infrastructure Orchestrator
# Calls our platform's webhook to deploy (our platform has AKS access!)
# Auto-runs on main branch or when triggered from UI

deploy_to_infrastructure:
  stage: deploy
  image: alpine:3.19
  before_script: []
  variables:
    DEPLOY_TARGET: "kubernetes"
    K8S_CLUSTER: "rg-irmai-uat-us-1-cluster"
    DEPLOY_NAMESPACE: "default"
    RESOURCE_GROUP: "rg-irmai-uat-us-1"
    ORCHESTRATOR_URL: "https://b5cefeed5009.ngrok-free.app"
    DEPLOY_IMAGE: "irmaiuatregistry.azurecr.io/irmai-kg-v2-surrealdb:$CI_COMMIT_SHORT_SHA"
  script: |
    echo "=== Deployment to Infrastructure ==="
    echo "Image: $DEPLOY_IMAGE"
    echo "Cluster: $K8S_CLUSTER"
    echo "Namespace: $DEPLOY_NAMESPACE"
    echo "Resource Group: $RESOURCE_GROUP"
    echo ""
    
    # Install required tools
    if ! command -v curl >/dev/null 2>&1; then
      echo "üì¶ Installing curl (alpine)..."
      apk add --no-cache curl >/tmp/curl-install.log 2>&1 || { echo "‚ùå Failed to install curl"; cat /tmp/curl-install.log; exit 1; }
    fi
    if ! command -v python3 >/dev/null 2>&1; then
      echo "üì¶ Installing python3 (alpine)..."
      apk add --no-cache python3 >/tmp/python-install.log 2>&1 || { echo "‚ùå Failed to install python3"; cat /tmp/python-install.log; exit 1; }
    fi
    
    # Step 1: Verify image exists in ACR (if it's an ACR image)
    if echo "$DEPLOY_IMAGE" | grep -q "\.azurecr\.io"; then
      echo ""
      echo "üîç Step 1: Verifying image exists in ACR..."
      ACR_REGISTRY=$(echo "$DEPLOY_IMAGE" | cut -d'/' -f1)
      IMAGE_WITH_TAG=$(echo "$DEPLOY_IMAGE" | cut -d'/' -f2-)
      IMAGE_NAME=$(echo "$IMAGE_WITH_TAG" | cut -d':' -f1)
      IMAGE_TAG=$(echo "$IMAGE_WITH_TAG" | cut -d':' -f2)
      ACR_NAME=$(echo "$ACR_REGISTRY" | cut -d'.' -f1)
      
      echo "   ACR: $ACR_NAME"
      echo "   Image: $IMAGE_NAME"
      echo "   Tag: $IMAGE_TAG"
      echo "   Full: $DEPLOY_IMAGE"
      
      # Check if we have Azure CLI available (for ACR checks)
      if command -v az >/dev/null 2>&1; then
        echo "   Using Azure CLI to verify image..."
        MAX_RETRIES=3
        RETRY_DELAY=5
        IMAGE_EXISTS=false
        
        for i in $(seq 1 $MAX_RETRIES); do
          echo "   Attempt $i/$MAX_RETRIES: Checking if tag exists..."
          TAG_CHECK=$(az acr repository show-tags \
            --name "$ACR_NAME" \
            --repository "$IMAGE_NAME" \
            --query "[?name=='$IMAGE_TAG'].name" -o tsv 2>&1)
          TAG_CHECK_EXIT=$?
          
          if [ $TAG_CHECK_EXIT -eq 0 ] && echo "$TAG_CHECK" | grep -q "$IMAGE_TAG"; then
            echo "   ‚úÖ Image tag found: $IMAGE_TAG"
            IMAGE_EXISTS=true
            break
          else
            echo "   ‚ö†Ô∏è  Tag not found (attempt $i/$MAX_RETRIES)"
            echo "   Output: $TAG_CHECK"
            if [ $i -lt $MAX_RETRIES ]; then
              echo "   ‚è≥ Waiting $RETRY_DELAY seconds before retry (ACR might still be processing)..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))  # Exponential backoff
            fi
          fi
        done
        
        if [ "$IMAGE_EXISTS" != "true" ]; then
          echo ""
          echo "‚ùå‚ùå‚ùå CRITICAL: Image tag '$IMAGE_TAG' NOT FOUND in ACR after $MAX_RETRIES attempts!"
          echo "   Expected image: $DEPLOY_IMAGE"
          echo "   ACR: $ACR_NAME"
          echo "   Repository: $IMAGE_NAME"
          echo ""
          echo "üí° Possible causes:"
          echo "   1. build_to_acr job failed or didn't complete"
          echo "   2. Image retagging failed (check build_to_acr job logs)"
          echo "   3. ACR is still processing the tag (unlikely after $MAX_RETRIES attempts)"
          echo "   4. Wrong tag name (check build_to_acr job for actual tag used)"
          echo ""
          echo "üîç Checking what tags DO exist in ACR..."
          ALL_TAGS=$(az acr repository show-tags --name "$ACR_NAME" --repository "$IMAGE_NAME" --query "[].name" -o tsv 2>&1 || echo "Failed to list tags")
          echo "   Available tags:"
          echo "$ALL_TAGS" | head -10 | while read tag; do
            echo "     - $tag"
          done
          if [ $(echo "$ALL_TAGS" | wc -l) -gt 10 ]; then
            echo "     ... (showing first 10, more exist)"
          fi
          echo ""
          echo "‚ö†Ô∏è  Deployment will likely fail, but continuing to show actual error from orchestrator"
        fi
      else
        echo "   ‚ö†Ô∏è  Azure CLI not available, skipping image verification"
        echo "   Will proceed with deployment (orchestrator will show error if image doesn't exist)"
      fi
    else
      echo ""
      echo "‚ÑπÔ∏è  Image is not from ACR (or format not recognized), skipping ACR verification"
      echo "   Image: $DEPLOY_IMAGE"
    fi
    
    echo ""
    echo "üîó Step 2: Calling Infrastructure Orchestrator webhook..."
    python3 - <<'PY'
    import json
    import os
    import sys
    import urllib.error
    import urllib.request
    from pathlib import Path

    url_base = os.environ.get("ORCHESTRATOR_URL")
    if not url_base:
        print("‚ùå ORCHESTRATOR_URL is not set", file=sys.stderr)
        print("   Please set ORCHESTRATOR_URL in GitLab CI/CD variables", file=sys.stderr)
        sys.exit(1)
    
    # Validate URL format
    url_base = url_base.rstrip("/")
    if not url_base.startswith(("http://", "https://")):
        print(f"‚ùå Invalid ORCHESTRATOR_URL format: {url_base}", file=sys.stderr)
        print("   ORCHESTRATOR_URL must start with http:// or https://", file=sys.stderr)
        sys.exit(1)
    
    print(f"üìç Using ORCHESTRATOR_URL: {url_base}")

    def _branch_for_release() -> str:
        branch = (
            os.environ.get("CI_COMMIT_BRANCH")
            or os.environ.get("CI_COMMIT_REF_NAME")
            or os.environ.get("CI_COMMIT_TAG")
            or os.environ.get("CI_DEFAULT_BRANCH")
            or ""
        )
        return branch or "main"

    payload_path = Path("payload.json")
    if payload_path.exists():
        payload = json.loads(payload_path.read_text() or "{}")
    else:
        commit_sha = os.environ.get("CI_COMMIT_SHORT_SHA", "")
        deploy_image = os.environ.get("DEPLOY_IMAGE", "")
        print(f"üîç Debug: CI_COMMIT_SHORT_SHA={commit_sha}")
        print(f"üîç Debug: DEPLOY_IMAGE (raw)={deploy_image}")
        # Resolve $CI_COMMIT_SHORT_SHA in DEPLOY_IMAGE if GitLab didn't resolve it
        if deploy_image and "$CI_COMMIT_SHORT_SHA" in deploy_image:
            deploy_image = deploy_image.replace("$CI_COMMIT_SHORT_SHA", commit_sha)
            print(f"üîç Debug: DEPLOY_IMAGE (resolved)={deploy_image}")
        payload = {
            "project_id": os.environ.get("CI_PROJECT_ID"),
            "project_name": os.environ.get("CI_PROJECT_NAME"),
            "image": deploy_image,
            "cluster_name": os.environ.get("K8S_CLUSTER"),
            "namespace": os.environ.get("DEPLOY_NAMESPACE"),
            "resource_group": os.environ.get("RESOURCE_GROUP"),
            "branch": "",
            "commit_sha": commit_sha,
        }

        services_json = os.environ.get("MULTI_SERVICE_CONFIG_JSON") or ""
        strategy_value = os.environ.get("DEPLOYMENT_STRATEGY") or ""
        if services_json:
            commit_sha = commit_sha or os.environ.get("CI_COMMIT_SHORT_SHA", "")
            rendered = services_json.replace("{{CI_COMMIT_SHORT_SHA}}", commit_sha)
            try:
                payload["services"] = json.loads(rendered)
            except json.JSONDecodeError as exc:
                print(f"‚ùå Failed to parse MULTI_SERVICE_CONFIG_JSON: {exc}", file=sys.stderr)
                sys.exit(1)
            payload["deployment_strategy"] = strategy_value or "helm_multi_service"
        
        # Read static IP configuration from CI variables if provided
        static_ip_json = os.environ.get("STATIC_IP_CONFIG_JSON") or ""
        if static_ip_json:
            try:
                payload["static_ip_config"] = json.loads(static_ip_json)
            except json.JSONDecodeError as exc:
                print(f"‚ö†Ô∏è  Failed to parse STATIC_IP_CONFIG_JSON: {exc}", file=sys.stderr)
                # Don't fail deployment if static IP config is invalid, just log warning

    payload.setdefault("commit_sha", os.environ.get("CI_COMMIT_SHORT_SHA", ""))
    payload["branch"] = payload.get("branch") or _branch_for_release()

    data = json.dumps(payload).encode()
    payload_path.write_bytes(data)

    url = url_base + "/webhooks/gitlab-deploy"
    print(f"üîó Calling webhook: {url}")
    print(f"üì¶ Payload: {json.dumps(json.loads(data.decode()), indent=2)}")

    req = urllib.request.Request(
        url,
        data=data,
        headers={"Content-Type": "application/json"},
        method="POST",
    )

    try:
        with urllib.request.urlopen(req, timeout=600) as resp:
            body = resp.read().decode() if resp.length != 0 else ""
            print(f"‚úÖ Webhook response status: {resp.status}")
            if body:
                try:
                    parsed = json.loads(body)
                    print(json.dumps(parsed, indent=2))
                except json.JSONDecodeError:
                    print(body)
    except urllib.error.HTTPError as exc:
        print(f"‚ùå Webhook call failed with status {exc.code}: {exc.reason}", file=sys.stderr)
        print(f"   URL: {url}", file=sys.stderr)
        try:
            error_body = exc.read().decode()
            if error_body:
                print(f"   Error details: {error_body}", file=sys.stderr)
                try:
                    error_json = json.loads(error_body)
                    if "detail" in error_json:
                        print(f"   Detail: {error_json['detail']}", file=sys.stderr)
                except json.JSONDecodeError:
                    pass
        except Exception:
            pass
        
        # Provide helpful error message for 404
        if exc.code == 404:
            print("", file=sys.stderr)
            print("üí° Troubleshooting:", file=sys.stderr)
            print("   1. Check ORCHESTRATOR_URL is set correctly in GitLab CI/CD variables", file=sys.stderr)
            print("   2. Verify the URL is accessible from GitLab CI runners", file=sys.stderr)
            print("   3. Ensure the API server is running and accessible", file=sys.stderr)
            print(f"   4. Expected endpoint: {url_base}/webhooks/gitlab-deploy", file=sys.stderr)
        
        sys.exit(exc.code if isinstance(exc.code, int) else 1)
    except urllib.error.URLError as url_err:
        print(f"‚ùå Webhook URL error: {url_err}", file=sys.stderr)
        print(f"   URL: {url}", file=sys.stderr)
        print("   This usually means the URL is unreachable or incorrect", file=sys.stderr)
        sys.exit(1)
    except Exception as err:
        print(f"‚ùå Webhook call error: {err}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        sys.exit(1)
    PY
    echo "Webhook called successfully"
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - if: $TRIGGER_DEPLOY == "true"
      when: on_success
    - when: manual
  allow_failure: false
