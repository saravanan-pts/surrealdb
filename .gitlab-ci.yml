# Tests disabled by Infra Orchestrator (skip_tests enabled)
# Docker Application CI/CD Pipeline
# Auto-generated for containerized application

stages:
  - build
  - deploy


# Build Docker image and push to Azure Container Registry
# Builds in GitLab CI (with disk space management) and pushes to ACR
# This is the proven working approach (see SUCCESS_ACR_DEPLOYMENT_WORKING.md)
build_to_acr:
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
  variables:
    ACR_REGISTRY: "irmaiuatregistry.azurecr.io"
    APP_NAME: "irmai-kg-v2-surrealdb"
    ORCHESTRATOR_URL: "https://b5cefeed5009.ngrok-free.app"
  before_script:
    - echo "=== Building Docker image and pushing to Azure Container Registry ==="
    - 'echo "ACR: $ACR_REGISTRY"'
    - 'echo "Image: $ACR_REGISTRY/$APP_NAME:$CI_COMMIT_SHORT_SHA"'
    - echo "Logging into Azure Container Registry..."
    - echo $ACR_PASSWORD | docker login $ACR_REGISTRY -u $ACR_USERNAME --password-stdin
  script:
    - |
      # Enable error handling
      set -e
      set -o pipefail
      
      echo "=========================================="
      echo "üöÄ Building Docker image"
      echo "=========================================="
      echo ""
      echo "üìã Configuration:"
      echo "   Registry: $ACR_REGISTRY"
      echo "   Image: $APP_NAME"
      echo "   Commit SHA: $CI_COMMIT_SHORT_SHA"
      echo "   Full image: $ACR_REGISTRY/$APP_NAME:$CI_COMMIT_SHORT_SHA"
      echo ""
      
      # Disk space management (critical for GitLab runners)
      echo "üßπ Cleaning up disk space before build..."
      docker system prune -f || true
      docker images --filter "dangling=true" -q | xargs -r docker rmi -f || true
      echo "Disk space before build:"
      df -h || true
      echo ""
      
      # Pull previous image for cache (if exists)
      echo "üì• Pulling previous image for cache (if exists)..."
      docker pull $ACR_REGISTRY/$APP_NAME:latest || echo "No previous image found, building from scratch"
      echo ""
      
      # Build image with cache
      echo "üèóÔ∏è  Building Docker image with cache..."
      docker build \
        --cache-from $ACR_REGISTRY/$APP_NAME:latest \
        -t $ACR_REGISTRY/$APP_NAME:$CI_COMMIT_SHORT_SHA \
        -t $ACR_REGISTRY/$APP_NAME:latest \
        .
      echo ""
      
      # Push images
      echo "üì§ Pushing images to ACR..."
      echo "   Pushing commit SHA tag: $ACR_REGISTRY/$APP_NAME:$CI_COMMIT_SHORT_SHA"
      docker push $ACR_REGISTRY/$APP_NAME:$CI_COMMIT_SHORT_SHA
      echo "   Pushing latest tag: $ACR_REGISTRY/$APP_NAME:latest"
      docker push $ACR_REGISTRY/$APP_NAME:latest
      echo ""
      
      # Cleanup to free space
      echo "üßπ Cleaning up after build..."
      docker rmi $ACR_REGISTRY/$APP_NAME:latest || echo "Failed to remove cache image, continuing..."
      docker system prune -f || true
      echo ""
      
      echo "=========================================="
      echo "‚úÖ‚úÖ‚úÖ Build Complete!"
      echo "=========================================="
      echo "   Built and pushed: $ACR_REGISTRY/$APP_NAME:$CI_COMMIT_SHORT_SHA"
      echo "   Latest tag: $ACR_REGISTRY/$APP_NAME:latest"
      echo "=========================================="
  after_script:
    - docker logout $ACR_REGISTRY || true
        - "[ -z \"$ORCHESTRATOR_URL\" ] && echo \"ORCHESTRATOR_URL not set; skipping Key Vault secret download\" && exit 0"
    - apk add --no-cache curl >/tmp/curl-install.log 2>&1 || { echo "‚ö†Ô∏è  Failed to install curl"; cat /tmp/curl-install.log; exit 1; }
    - "response_status=$(curl -sS -o keyvault.env -w \"%{http_code}\" -X POST \"$ORCHESTRATOR_URL/keyvault/env\" -H \"Content-Type: application/json\" -d '{\"application_name\":\"'$CI_PROJECT_NAME'\",\"format\":\"dotenv\"}')"
    - "[ \"$response_status\" = \"200\" ] && mv keyvault.env .env && ([ \".\" != \".\" ] && cp .env \"./.env\" || true) && echo \"‚úÖ Secrets written to .env\" || (rm -f keyvault.env && echo \"‚ÑπÔ∏è  No secrets fetched from orchestrator (status $response_status)\")"
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - if: $TRIGGER_DEPLOY == "true"
      when: on_success
    - exists:
        - docker-compose.yml
      when: on_success


# Deployment job added by Infrastructure Orchestrator
# Calls our platform's webhook to deploy (our platform has AKS access!)
# Auto-runs on main branch or when triggered from UI

deploy_to_infrastructure:
  stage: deploy
  image: alpine:3.19
  before_script: []
  variables:
    DEPLOY_TARGET: "kubernetes"
    K8S_CLUSTER: "rg-irmai-uat-us-1-cluster"
    DEPLOY_NAMESPACE: "default"
    RESOURCE_GROUP: "rg-irmai-uat-us-1"
    ORCHESTRATOR_URL: "https://b5cefeed5009.ngrok-free.app"
    DEPLOY_IMAGE: "irmaiuatregistry.azurecr.io/irmai-kg-v2-surrealdb:$CI_COMMIT_SHORT_SHA"
  script: |
    echo "=== Deployment to Infrastructure ==="
    echo "Image: $DEPLOY_IMAGE"
    echo "Cluster: $K8S_CLUSTER"
    echo "Namespace: $DEPLOY_NAMESPACE"
    echo "Resource Group: $RESOURCE_GROUP"
    echo ""
    
    # Install required tools
    if ! command -v curl >/dev/null 2>&1; then
      echo "üì¶ Installing curl (alpine)..."
      apk add --no-cache curl >/tmp/curl-install.log 2>&1 || { echo "‚ùå Failed to install curl"; cat /tmp/curl-install.log; exit 1; }
    fi
    if ! command -v python3 >/dev/null 2>&1; then
      echo "üì¶ Installing python3 (alpine)..."
      apk add --no-cache python3 >/tmp/python-install.log 2>&1 || { echo "‚ùå Failed to install python3"; cat /tmp/python-install.log; exit 1; }
    fi
    
    # Step 1: Verify image exists in ACR (if it's an ACR image)
    if echo "$DEPLOY_IMAGE" | grep -q "\.azurecr\.io"; then
      echo ""
      echo "üîç Step 1: Verifying image exists in ACR..."
      ACR_REGISTRY=$(echo "$DEPLOY_IMAGE" | cut -d'/' -f1)
      IMAGE_WITH_TAG=$(echo "$DEPLOY_IMAGE" | cut -d'/' -f2-)
      IMAGE_NAME=$(echo "$IMAGE_WITH_TAG" | cut -d':' -f1)
      IMAGE_TAG=$(echo "$IMAGE_WITH_TAG" | cut -d':' -f2)
      ACR_NAME=$(echo "$ACR_REGISTRY" | cut -d'.' -f1)
      
      echo "   ACR: $ACR_NAME"
      echo "   Image: $IMAGE_NAME"
      echo "   Tag: $IMAGE_TAG"
      echo "   Full: $DEPLOY_IMAGE"
      
      # Check if we have Azure CLI available (for ACR checks)
      if command -v az >/dev/null 2>&1; then
        echo "   Using Azure CLI to verify image..."
        MAX_RETRIES=3
        RETRY_DELAY=5
        IMAGE_EXISTS=false
        
        for i in $(seq 1 $MAX_RETRIES); do
          echo "   Attempt $i/$MAX_RETRIES: Checking if tag exists..."
          TAG_CHECK=$(az acr repository show-tags \
            --name "$ACR_NAME" \
            --repository "$IMAGE_NAME" \
            --query "[?name=='$IMAGE_TAG'].name" -o tsv 2>&1)
          TAG_CHECK_EXIT=$?
          
          if [ $TAG_CHECK_EXIT -eq 0 ] && echo "$TAG_CHECK" | grep -q "$IMAGE_TAG"; then
            echo "   ‚úÖ Image tag found: $IMAGE_TAG"
            IMAGE_EXISTS=true
            break
          else
            echo "   ‚ö†Ô∏è  Tag not found (attempt $i/$MAX_RETRIES)"
            echo "   Output: $TAG_CHECK"
            if [ $i -lt $MAX_RETRIES ]; then
              echo "   ‚è≥ Waiting $RETRY_DELAY seconds before retry (ACR might still be processing)..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))  # Exponential backoff
            fi
          fi
        done
        
        if [ "$IMAGE_EXISTS" != "true" ]; then
          echo ""
          echo "‚ùå‚ùå‚ùå CRITICAL: Image tag '$IMAGE_TAG' NOT FOUND in ACR after $MAX_RETRIES attempts!"
          echo "   Expected image: $DEPLOY_IMAGE"
          echo "   ACR: $ACR_NAME"
          echo "   Repository: $IMAGE_NAME"
          echo ""
          echo "üí° Possible causes:"
          echo "   1. build_to_acr job failed or didn't complete"
          echo "   2. Image retagging failed (check build_to_acr job logs)"
          echo "   3. ACR is still processing the tag (unlikely after $MAX_RETRIES attempts)"
          echo "   4. Wrong tag name (check build_to_acr job for actual tag used)"
          echo ""
          echo "üîç Checking what tags DO exist in ACR..."
          ALL_TAGS=$(az acr repository show-tags --name "$ACR_NAME" --repository "$IMAGE_NAME" --query "[].name" -o tsv 2>&1 || echo "Failed to list tags")
          echo "   Available tags:"
          echo "$ALL_TAGS" | head -10 | while read tag; do
            echo "     - $tag"
          done
          if [ $(echo "$ALL_TAGS" | wc -l) -gt 10 ]; then
            echo "     ... (showing first 10, more exist)"
          fi
          echo ""
          echo "‚ö†Ô∏è  Deployment will likely fail, but continuing to show actual error from orchestrator"
        fi
      else
        echo "   ‚ö†Ô∏è  Azure CLI not available, skipping image verification"
        echo "   Will proceed with deployment (orchestrator will show error if image doesn't exist)"
      fi
    else
      echo ""
      echo "‚ÑπÔ∏è  Image is not from ACR (or format not recognized), skipping ACR verification"
      echo "   Image: $DEPLOY_IMAGE"
    fi
    
    echo ""
    echo "üîó Step 2: Calling Infrastructure Orchestrator webhook..."
    python3 - <<'PY'
    import json
    import os
    import sys
    import urllib.error
    import urllib.request
    from pathlib import Path

    url_base = os.environ.get("ORCHESTRATOR_URL")
    if not url_base:
        print("‚ùå ORCHESTRATOR_URL is not set", file=sys.stderr)
        print("   Please set ORCHESTRATOR_URL in GitLab CI/CD variables", file=sys.stderr)
        sys.exit(1)
    
    # Validate URL format
    url_base = url_base.rstrip("/")
    if not url_base.startswith(("http://", "https://")):
        print(f"‚ùå Invalid ORCHESTRATOR_URL format: {url_base}", file=sys.stderr)
        print("   ORCHESTRATOR_URL must start with http:// or https://", file=sys.stderr)
        sys.exit(1)
    
    print(f"üìç Using ORCHESTRATOR_URL: {url_base}")

    def _branch_for_release() -> str:
        branch = (
            os.environ.get("CI_COMMIT_BRANCH")
            or os.environ.get("CI_COMMIT_REF_NAME")
            or os.environ.get("CI_COMMIT_TAG")
            or os.environ.get("CI_DEFAULT_BRANCH")
            or ""
        )
        return branch or "main"

    payload_path = Path("payload.json")
    if payload_path.exists():
        payload = json.loads(payload_path.read_text() or "{}")
    else:
        commit_sha = os.environ.get("CI_COMMIT_SHORT_SHA", "")
        deploy_image = os.environ.get("DEPLOY_IMAGE", "")
        print(f"üîç Debug: CI_COMMIT_SHORT_SHA={commit_sha}")
        print(f"üîç Debug: DEPLOY_IMAGE (raw)={deploy_image}")
        # Resolve $CI_COMMIT_SHORT_SHA in DEPLOY_IMAGE if GitLab didn't resolve it
        if deploy_image and "$CI_COMMIT_SHORT_SHA" in deploy_image:
            deploy_image = deploy_image.replace("$CI_COMMIT_SHORT_SHA", commit_sha)
            print(f"üîç Debug: DEPLOY_IMAGE (resolved)={deploy_image}")
        payload = {
            "project_id": os.environ.get("CI_PROJECT_ID"),
            "project_name": os.environ.get("CI_PROJECT_NAME"),
            "image": deploy_image,
            "cluster_name": os.environ.get("K8S_CLUSTER"),
            "namespace": os.environ.get("DEPLOY_NAMESPACE"),
            "resource_group": os.environ.get("RESOURCE_GROUP"),
            "branch": "",
            "commit_sha": commit_sha,
        }

        services_json = os.environ.get("MULTI_SERVICE_CONFIG_JSON") or ""
        strategy_value = os.environ.get("DEPLOYMENT_STRATEGY") or ""
        if services_json:
            commit_sha = commit_sha or os.environ.get("CI_COMMIT_SHORT_SHA", "")
            rendered = services_json.replace("{{CI_COMMIT_SHORT_SHA}}", commit_sha)
            try:
                payload["services"] = json.loads(rendered)
            except json.JSONDecodeError as exc:
                print(f"‚ùå Failed to parse MULTI_SERVICE_CONFIG_JSON: {exc}", file=sys.stderr)
                sys.exit(1)
            payload["deployment_strategy"] = strategy_value or "helm_multi_service"
        
        # Read static IP configuration from CI variables if provided
        static_ip_json = os.environ.get("STATIC_IP_CONFIG_JSON") or ""
        if static_ip_json:
            try:
                payload["static_ip_config"] = json.loads(static_ip_json)
            except json.JSONDecodeError as exc:
                print(f"‚ö†Ô∏è  Failed to parse STATIC_IP_CONFIG_JSON: {exc}", file=sys.stderr)
                # Don't fail deployment if static IP config is invalid, just log warning

    payload.setdefault("commit_sha", os.environ.get("CI_COMMIT_SHORT_SHA", ""))
    payload["branch"] = payload.get("branch") or _branch_for_release()

    data = json.dumps(payload).encode()
    payload_path.write_bytes(data)

    url = url_base + "/webhooks/gitlab-deploy"
    print(f"üîó Calling webhook: {url}")
    print(f"üì¶ Payload: {json.dumps(json.loads(data.decode()), indent=2)}")

    req = urllib.request.Request(
        url,
        data=data,
        headers={"Content-Type": "application/json"},
        method="POST",
    )

    try:
        with urllib.request.urlopen(req, timeout=600) as resp:
            body = resp.read().decode() if resp.length != 0 else ""
            print(f"‚úÖ Webhook response status: {resp.status}")
            if body:
                try:
                    parsed = json.loads(body)
                    print(json.dumps(parsed, indent=2))
                except json.JSONDecodeError:
                    print(body)
    except urllib.error.HTTPError as exc:
        print(f"‚ùå Webhook call failed with status {exc.code}: {exc.reason}", file=sys.stderr)
        print(f"   URL: {url}", file=sys.stderr)
        try:
            error_body = exc.read().decode()
            if error_body:
                print(f"   Error details: {error_body}", file=sys.stderr)
                try:
                    error_json = json.loads(error_body)
                    if "detail" in error_json:
                        print(f"   Detail: {error_json['detail']}", file=sys.stderr)
                except json.JSONDecodeError:
                    pass
        except Exception:
            pass
        
        # Provide helpful error message for 404
        if exc.code == 404:
            print("", file=sys.stderr)
            print("üí° Troubleshooting:", file=sys.stderr)
            print("   1. Check ORCHESTRATOR_URL is set correctly in GitLab CI/CD variables", file=sys.stderr)
            print("   2. Verify the URL is accessible from GitLab CI runners", file=sys.stderr)
            print("   3. Ensure the API server is running and accessible", file=sys.stderr)
            print(f"   4. Expected endpoint: {url_base}/webhooks/gitlab-deploy", file=sys.stderr)
        
        sys.exit(exc.code if isinstance(exc.code, int) else 1)
    except urllib.error.URLError as url_err:
        print(f"‚ùå Webhook URL error: {url_err}", file=sys.stderr)
        print(f"   URL: {url}", file=sys.stderr)
        print("   This usually means the URL is unreachable or incorrect", file=sys.stderr)
        sys.exit(1)
    except Exception as err:
        print(f"‚ùå Webhook call error: {err}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        sys.exit(1)
    PY
    echo "Webhook called successfully"
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - if: $TRIGGER_DEPLOY == "true"
      when: on_success
    - when: manual
  allow_failure: false
